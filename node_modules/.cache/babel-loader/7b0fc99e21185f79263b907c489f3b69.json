{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FileAudioSource = void 0;\n\nvar Exports_1 = require(\"../common.speech/Exports\");\n\nvar Exports_2 = require(\"../common/Exports\");\n\nvar AudioStreamFormat_1 = require(\"../sdk/Audio/AudioStreamFormat\");\n\nvar FileAudioSource = function () {\n  function FileAudioSource(file, filename, audioSourceId) {\n    var _this = this;\n\n    this.privStreams = {};\n    this.privHeaderEnd = 44;\n\n    this.turnOn = function () {\n      if (_this.privFilename.lastIndexOf(\".wav\") !== _this.privFilename.length - 4) {\n        var errorMsg = _this.privFilename + \" is not supported. Only WAVE files are allowed at the moment.\";\n\n        _this.onEvent(new Exports_2.AudioSourceErrorEvent(errorMsg, \"\"));\n\n        return Promise.reject(errorMsg);\n      }\n\n      _this.onEvent(new Exports_2.AudioSourceInitializingEvent(_this.privId)); // no stream id\n\n\n      _this.onEvent(new Exports_2.AudioSourceReadyEvent(_this.privId));\n\n      return;\n    };\n\n    this.id = function () {\n      return _this.privId;\n    };\n\n    this.attach = function (audioNodeId) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var stream;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              this.onEvent(new Exports_2.AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n              return [4\n              /*yield*/\n              , this.upload(audioNodeId)];\n\n            case 1:\n              stream = _a.sent();\n              this.onEvent(new Exports_2.AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n              return [2\n              /*return*/\n              , Promise.resolve({\n                detach: function () {\n                  return __awaiter(_this, void 0, void 0, function () {\n                    return __generator(this, function (_a) {\n                      switch (_a.label) {\n                        case 0:\n                          stream.readEnded();\n                          delete this.privStreams[audioNodeId];\n                          this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n                          return [4\n                          /*yield*/\n                          , this.turnOff()];\n\n                        case 1:\n                          _a.sent();\n\n                          return [2\n                          /*return*/\n                          ];\n                      }\n                    });\n                  });\n                },\n                id: function () {\n                  return audioNodeId;\n                },\n                read: function () {\n                  return stream.read();\n                }\n              })];\n          }\n        });\n      });\n    };\n\n    this.detach = function (audioNodeId) {\n      if (audioNodeId && _this.privStreams[audioNodeId]) {\n        _this.privStreams[audioNodeId].close();\n\n        delete _this.privStreams[audioNodeId];\n\n        _this.onEvent(new Exports_2.AudioStreamNodeDetachedEvent(_this.privId, audioNodeId));\n      }\n    };\n\n    this.turnOff = function () {\n      for (var streamId in _this.privStreams) {\n        if (streamId) {\n          var stream = _this.privStreams[streamId];\n\n          if (stream && !stream.isClosed) {\n            stream.close();\n          }\n        }\n      }\n\n      _this.onEvent(new Exports_2.AudioSourceOffEvent(_this.privId)); // no stream now\n\n\n      return Promise.resolve();\n    };\n\n    this.onEvent = function (event) {\n      _this.privEvents.onEvent(event);\n\n      Exports_2.Events.instance.onEvent(event);\n    };\n\n    this.privId = audioSourceId ? audioSourceId : Exports_2.createNoDashGuid();\n    this.privEvents = new Exports_2.EventSource();\n    this.privSource = file;\n\n    if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && this.privSource instanceof Blob) {\n      this.privFilename = file.name;\n    } else {\n      this.privFilename = filename || \"unknown.wav\";\n    } // Read the header.\n\n\n    this.privAudioFormatPromise = this.readHeader();\n  }\n\n  Object.defineProperty(FileAudioSource.prototype, \"format\", {\n    get: function () {\n      return this.privAudioFormatPromise;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileAudioSource.prototype, \"blob\", {\n    get: function () {\n      return Promise.resolve(this.privSource);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileAudioSource.prototype, \"events\", {\n    get: function () {\n      return this.privEvents;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(FileAudioSource.prototype, \"deviceInfo\", {\n    get: function () {\n      return this.privAudioFormatPromise.then(function (result) {\n        return Promise.resolve({\n          bitspersample: result.bitsPerSample,\n          channelcount: result.channels,\n          connectivity: Exports_1.connectivity.Unknown,\n          manufacturer: \"Speech SDK\",\n          model: \"File\",\n          samplerate: result.samplesPerSec,\n          type: Exports_1.type.File\n        });\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  FileAudioSource.prototype.readHeader = function () {\n    var _this = this; // Read the wave header.\n\n\n    var maxHeaderSize = 512;\n    var header = this.privSource.slice(0, maxHeaderSize);\n    var headerResult = new Exports_2.Deferred();\n\n    var processHeader = function (header) {\n      var view = new DataView(header);\n\n      var getWord = function (index) {\n        return String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\n      }; // RIFF 4 bytes.\n\n\n      if (\"RIFF\" !== getWord(0)) {\n        headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\n        return;\n      } // length, 4 bytes\n      // RIFF Type & fmt 8 bytes\n\n\n      if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\n        headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\n        return;\n      }\n\n      var formatSize = view.getInt32(16, true);\n      var channelCount = view.getUint16(22, true);\n      var sampleRate = view.getUint32(24, true);\n      var bitsPerSample = view.getUint16(34, true); // Confirm if header is 44 bytes long.\n\n      var pos = 36 + Math.max(formatSize - 16, 0);\n\n      for (; getWord(pos) !== \"data\"; pos += 2) {\n        if (pos > maxHeaderSize - 8) {\n          headerResult.reject(\"Invalid WAV header in file, data block was not found\");\n          return;\n        }\n      }\n\n      _this.privHeaderEnd = pos + 8;\n      headerResult.resolve(AudioStreamFormat_1.AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount));\n    };\n\n    if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && header instanceof Blob) {\n      var reader = new FileReader();\n\n      reader.onload = function (event) {\n        var header = event.target.result;\n        processHeader(header);\n      };\n\n      reader.readAsArrayBuffer(header);\n    } else {\n      var h = header;\n      processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));\n    }\n\n    return headerResult.promise;\n  };\n\n  FileAudioSource.prototype.upload = function (audioNodeId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var onerror, format, stream_1, chunk, processFile_1, reader, c, e_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            onerror = function (error) {\n              var errorMsg = \"Error occurred while processing '\" + _this.privFilename + \"'. \" + error;\n\n              _this.onEvent(new Exports_2.AudioStreamNodeErrorEvent(_this.privId, audioNodeId, errorMsg));\n\n              throw new Error(errorMsg);\n            };\n\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.turnOn()];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.privAudioFormatPromise];\n\n          case 3:\n            format = _a.sent();\n            stream_1 = new Exports_2.ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\n            this.privStreams[audioNodeId] = stream_1;\n            chunk = this.privSource.slice(this.privHeaderEnd);\n\n            processFile_1 = function (buff) {\n              if (stream_1.isClosed) {\n                return; // output stream was closed (somebody called TurnOff). We're done here.\n              }\n\n              stream_1.writeStreamChunk({\n                buffer: buff,\n                isEnd: false,\n                timeReceived: Date.now()\n              });\n              stream_1.close();\n            };\n\n            if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && chunk instanceof Blob) {\n              reader = new FileReader();\n\n              reader.onerror = function (ev) {\n                onerror(ev.toString());\n              };\n\n              reader.onload = function (event) {\n                var fileBuffer = event.target.result;\n                processFile_1(fileBuffer);\n              };\n\n              reader.readAsArrayBuffer(chunk);\n            } else {\n              c = chunk;\n              processFile_1(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));\n            }\n\n            return [2\n            /*return*/\n            , stream_1];\n\n          case 4:\n            e_1 = _a.sent();\n            onerror(e_1);\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return FileAudioSource;\n}();\n\nexports.FileAudioSource = FileAudioSource;","map":{"version":3,"sources":["src/common.browser/FileAudioSource.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    connectivity,\r\n    ISpeechConfigAudioDevice,\r\n    type,\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioSourceEvent,\r\n    AudioSourceInitializingEvent,\r\n    AudioSourceOffEvent,\r\n    AudioSourceReadyEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    ChunkedArrayBufferStream,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IStreamChunk,\r\n    IStringDictionary,\r\n    Stream,\r\n} from \"../common/Exports\";\r\nimport { AudioStreamFormat, AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\n\r\nexport class FileAudioSource implements IAudioSource {\r\n\r\n    private privAudioFormatPromise: Promise<AudioStreamFormatImpl>;\r\n\r\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\r\n\r\n    private privId: string;\r\n\r\n    private privEvents: EventSource<AudioSourceEvent>;\r\n\r\n    private privSource: Blob | Buffer;\r\n\r\n    private privFilename: string;\r\n\r\n    private privHeaderEnd: number = 44;\r\n\r\n    public constructor(file: File | Buffer, filename?: string, audioSourceId?: string) {\r\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\r\n        this.privEvents = new EventSource<AudioSourceEvent>();\r\n        this.privSource = file;\r\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && this.privSource instanceof Blob) {\r\n            this.privFilename = (file as File).name;\r\n        } else {\r\n            this.privFilename = filename || \"unknown.wav\";\r\n        }\r\n\r\n        // Read the header.\r\n        this.privAudioFormatPromise = this.readHeader();\r\n    }\r\n\r\n    public get format(): Promise<AudioStreamFormatImpl> {\r\n        return this.privAudioFormatPromise;\r\n    }\r\n\r\n    public get blob(): Promise<Blob | Buffer> {\r\n        return Promise.resolve(this.privSource);\r\n    }\r\n\r\n    public turnOn = (): Promise<void> => {\r\n        if (this.privFilename.lastIndexOf(\".wav\") !== this.privFilename.length - 4) {\r\n            const errorMsg = this.privFilename + \" is not supported. Only WAVE files are allowed at the moment.\";\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\r\n            return Promise.reject(errorMsg);\r\n        }\r\n\r\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\r\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n        return;\r\n    }\r\n\r\n    public id = (): string => {\r\n        return this.privId;\r\n    }\r\n\r\n    public attach = async (audioNodeId: string): Promise<IAudioStreamNode> => {\r\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\r\n\r\n        const stream: Stream<ArrayBuffer> = await this.upload(audioNodeId);\r\n\r\n        this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\r\n        return Promise.resolve({\r\n            detach: async (): Promise<void> => {\r\n                stream.readEnded();\r\n                delete this.privStreams[audioNodeId];\r\n                this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n                await this.turnOff();\r\n            },\r\n            id: () => {\r\n                return audioNodeId;\r\n            },\r\n            read: (): Promise<IStreamChunk<ArrayBuffer>> => {\r\n                return stream.read();\r\n            },\r\n        });\r\n    }\r\n\r\n    public detach = (audioNodeId: string): void => {\r\n        if (audioNodeId && this.privStreams[audioNodeId]) {\r\n            this.privStreams[audioNodeId].close();\r\n            delete this.privStreams[audioNodeId];\r\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n        }\r\n    }\r\n\r\n    public turnOff = (): Promise<void> => {\r\n        for (const streamId in this.privStreams) {\r\n            if (streamId) {\r\n                const stream = this.privStreams[streamId];\r\n                if (stream && !stream.isClosed) {\r\n                    stream.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public get events(): EventSource<AudioSourceEvent> {\r\n        return this.privEvents;\r\n    }\r\n\r\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\r\n        return this.privAudioFormatPromise.then<ISpeechConfigAudioDevice>((result: AudioStreamFormatImpl) => {\r\n            return Promise.resolve({\r\n                bitspersample: result.bitsPerSample,\r\n                channelcount: result.channels,\r\n                connectivity: connectivity.Unknown,\r\n                manufacturer: \"Speech SDK\",\r\n                model: \"File\",\r\n                samplerate: result.samplesPerSec,\r\n                type: type.File,\r\n            });\r\n        });\r\n    }\r\n\r\n    private readHeader(): Promise<AudioStreamFormatImpl> {\r\n        // Read the wave header.\r\n        const maxHeaderSize: number = 512;\r\n        const header: Blob | Buffer = this.privSource.slice(0, maxHeaderSize);\r\n\r\n        const headerResult: Deferred<AudioStreamFormatImpl> = new Deferred<AudioStreamFormatImpl>();\r\n\r\n        const processHeader = (header: ArrayBuffer): void => {\r\n            const view: DataView = new DataView(header);\r\n\r\n            const getWord = (index: number): string => {\r\n                return String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\r\n            };\r\n\r\n            // RIFF 4 bytes.\r\n            if (\"RIFF\" !== getWord(0)) {\r\n                headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\r\n                return;\r\n            }\r\n\r\n            // length, 4 bytes\r\n            // RIFF Type & fmt 8 bytes\r\n            if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\r\n                headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\r\n                return;\r\n            }\r\n\r\n            const formatSize: number = view.getInt32(16, true);\r\n            const channelCount: number = view.getUint16(22, true);\r\n            const sampleRate: number = view.getUint32(24, true);\r\n            const bitsPerSample: number = view.getUint16(34, true);\r\n            // Confirm if header is 44 bytes long.\r\n            let pos: number = 36 + Math.max(formatSize - 16, 0);\r\n            for (; getWord(pos) !== \"data\"; pos += 2) {\r\n                if (pos > maxHeaderSize - 8) {\r\n                    headerResult.reject(\"Invalid WAV header in file, data block was not found\");\r\n                    return;\r\n                }\r\n            }\r\n            this.privHeaderEnd = pos + 8;\r\n            headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount) as AudioStreamFormatImpl);\r\n        };\r\n\r\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && header instanceof Blob) {\r\n            const reader: FileReader = new FileReader();\r\n\r\n            reader.onload = (event: Event) => {\r\n                const header: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\r\n                processHeader(header);\r\n            };\r\n\r\n            reader.readAsArrayBuffer(header);\r\n        } else {\r\n            const h: Buffer = header as Buffer;\r\n            processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));\r\n        }\r\n        return headerResult.promise;\r\n    }\r\n\r\n    private async upload(audioNodeId: string): Promise<Stream<ArrayBuffer>> {\r\n        const onerror = (error: string) => {\r\n            const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;\r\n            this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\r\n            throw new Error(errorMsg);\r\n        };\r\n\r\n        try {\r\n            await this.turnOn();\r\n\r\n            const format: AudioStreamFormatImpl = await this.privAudioFormatPromise;\r\n            const stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\r\n\r\n            this.privStreams[audioNodeId] = stream;\r\n            const chunk: Blob | Buffer = this.privSource.slice(this.privHeaderEnd);\r\n\r\n            const processFile = (buff: ArrayBuffer): void => {\r\n                if (stream.isClosed) {\r\n                    return; // output stream was closed (somebody called TurnOff). We're done here.\r\n                }\r\n\r\n                stream.writeStreamChunk({\r\n                    buffer: buff,\r\n                    isEnd: false,\r\n                    timeReceived: Date.now(),\r\n                });\r\n                stream.close();\r\n            };\r\n\r\n            if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && chunk instanceof Blob) {\r\n                const reader: FileReader = new FileReader();\r\n                reader.onerror = (ev: ProgressEvent<FileReader>) => { onerror(ev.toString()); };\r\n\r\n                reader.onload = (event: Event) => {\r\n                    const fileBuffer: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\r\n                    processFile(fileBuffer);\r\n                };\r\n\r\n                reader.readAsArrayBuffer(chunk);\r\n            } else {\r\n                const c: Buffer = chunk as Buffer;\r\n                processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));\r\n            }\r\n\r\n            return stream;\r\n        } catch (e) {\r\n            onerror(e);\r\n        }\r\n    }\r\n\r\n    private onEvent = (event: AudioSourceEvent): void => {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}