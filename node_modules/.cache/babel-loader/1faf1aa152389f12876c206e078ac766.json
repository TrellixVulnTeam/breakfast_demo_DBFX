{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PcmRecorder = void 0;\n\nvar Exports_1 = require(\"../common/Exports\");\n\nvar PcmRecorder = function () {\n  function PcmRecorder(stopInputOnRelease) {\n    var _this = this;\n\n    this.record = function (context, mediaStream, outputStream) {\n      var desiredSampleRate = 16000;\n      var waveStreamEncoder = new Exports_1.RiffPcmEncoder(context.sampleRate, desiredSampleRate);\n      var needHeader = true;\n      var micInput = context.createMediaStreamSource(mediaStream);\n\n      if (!_this.privSpeechProcessorScript) {\n        var workletScript = \"class SP extends AudioWorkletProcessor {\\n                constructor(options) {\\n                  super(options);\\n                }\\n                process(inputs, outputs) {\\n                  const input = inputs[0];\\n                  const output = [];\\n                  for (let channel = 0; channel < input.length; channel += 1) {\\n                    output[channel] = input[channel];\\n                  }\\n                  this.port.postMessage(output[0]);\\n                  return true;\\n                }\\n              }\\n              registerProcessor('speech-processor', SP);\"; // tslint:disable-line:max-line-length\n\n        var blob = new Blob([workletScript], {\n          type: \"application/javascript; charset=utf-8\"\n        });\n        _this.privSpeechProcessorScript = URL.createObjectURL(blob);\n      } // https://webaudio.github.io/web-audio-api/#audioworklet\n      // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\n\n\n      if (!!_this.privSpeechProcessorScript && !!context.audioWorklet) {\n        context.audioWorklet.addModule(_this.privSpeechProcessorScript).then(function () {\n          var workletNode = new AudioWorkletNode(context, \"speech-processor\");\n\n          workletNode.port.onmessage = function (ev) {\n            var inputFrame = ev.data;\n\n            if (outputStream && !outputStream.isClosed) {\n              var waveFrame = waveStreamEncoder.encode(inputFrame);\n\n              if (!!waveFrame) {\n                outputStream.writeStreamChunk({\n                  buffer: waveFrame,\n                  isEnd: false,\n                  timeReceived: Date.now()\n                });\n                needHeader = false;\n              }\n            }\n          };\n\n          micInput.connect(workletNode);\n          workletNode.connect(context.destination);\n          _this.privMediaResources = {\n            scriptProcessorNode: workletNode,\n            source: micInput,\n            stream: mediaStream\n          };\n        }).catch(function () {\n          var scriptNode = function () {\n            var bufferSize = 0;\n\n            try {\n              return context.createScriptProcessor(bufferSize, 1, 1);\n            } catch (error) {\n              // Webkit (<= version 31) requires a valid bufferSize.\n              bufferSize = 2048;\n              var audioSampleRate = context.sampleRate;\n\n              while (bufferSize < 16384 && audioSampleRate >= 2 * desiredSampleRate) {\n                bufferSize <<= 1;\n                audioSampleRate >>= 1;\n              }\n\n              return context.createScriptProcessor(bufferSize, 1, 1);\n            }\n          }();\n\n          scriptNode.onaudioprocess = function (event) {\n            var inputFrame = event.inputBuffer.getChannelData(0);\n\n            if (outputStream && !outputStream.isClosed) {\n              var waveFrame = waveStreamEncoder.encode(inputFrame);\n\n              if (!!waveFrame) {\n                outputStream.writeStreamChunk({\n                  buffer: waveFrame,\n                  isEnd: false,\n                  timeReceived: Date.now()\n                });\n                needHeader = false;\n              }\n            }\n          };\n\n          micInput.connect(scriptNode);\n          scriptNode.connect(context.destination);\n          _this.privMediaResources = {\n            scriptProcessorNode: scriptNode,\n            source: micInput,\n            stream: mediaStream\n          };\n        });\n      } else {\n        throw new Error(\"Unable to start audio worklet node for PCMRecorder\");\n      }\n    };\n\n    this.releaseMediaResources = function (context) {\n      if (_this.privMediaResources) {\n        if (_this.privMediaResources.scriptProcessorNode) {\n          _this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\n\n          _this.privMediaResources.scriptProcessorNode = null;\n        }\n\n        if (_this.privMediaResources.source) {\n          _this.privMediaResources.source.disconnect();\n\n          if (_this.privStopInputOnRelease) {\n            _this.privMediaResources.stream.getTracks().forEach(function (track) {\n              return track.stop();\n            });\n          }\n\n          _this.privMediaResources.source = null;\n        }\n      }\n    };\n\n    this.privStopInputOnRelease = stopInputOnRelease;\n  }\n\n  PcmRecorder.prototype.setWorkletUrl = function (url) {\n    this.privSpeechProcessorScript = url;\n  };\n\n  return PcmRecorder;\n}();\n\nexports.PcmRecorder = PcmRecorder;","map":{"version":3,"sources":["src/common.browser/PCMRecorder.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { RiffPcmEncoder, Stream } from \"../common/Exports\";\r\nimport { IRecorder } from \"./IRecorder\";\r\n\r\nexport class PcmRecorder implements IRecorder {\r\n    private privMediaResources: IMediaResources;\r\n    private privSpeechProcessorScript: string; // speech-processor.js Url\r\n    private privStopInputOnRelease: boolean;\r\n\r\n    public constructor(stopInputOnRelease: boolean) {\r\n        this.privStopInputOnRelease = stopInputOnRelease;\r\n    }\r\n\r\n    public record = (context: AudioContext, mediaStream: MediaStream, outputStream: Stream<ArrayBuffer>): void => {\r\n        const desiredSampleRate = 16000;\r\n\r\n        const waveStreamEncoder = new RiffPcmEncoder(context.sampleRate, desiredSampleRate);\r\n        let needHeader: boolean = true;\r\n\r\n        const micInput = context.createMediaStreamSource(mediaStream);\r\n        if (!this.privSpeechProcessorScript) {\r\n            const workletScript = `class SP extends AudioWorkletProcessor {\r\n                constructor(options) {\r\n                  super(options);\r\n                }\r\n                process(inputs, outputs) {\r\n                  const input = inputs[0];\r\n                  const output = [];\r\n                  for (let channel = 0; channel < input.length; channel += 1) {\r\n                    output[channel] = input[channel];\r\n                  }\r\n                  this.port.postMessage(output[0]);\r\n                  return true;\r\n                }\r\n              }\r\n              registerProcessor('speech-processor', SP);`; // tslint:disable-line:max-line-length\r\n            const blob = new Blob([workletScript], { type: \"application/javascript; charset=utf-8\" });\r\n            this.privSpeechProcessorScript = URL.createObjectURL(blob);\r\n        }\r\n\r\n        // https://webaudio.github.io/web-audio-api/#audioworklet\r\n        // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\r\n\r\n        if (!!this.privSpeechProcessorScript && !!context.audioWorklet) {\r\n            context.audioWorklet\r\n                .addModule(this.privSpeechProcessorScript)\r\n                .then(() => {\r\n                    const workletNode = new AudioWorkletNode(context, \"speech-processor\");\r\n                    workletNode.port.onmessage = (ev: MessageEvent) => {\r\n                        const inputFrame: Float32Array = ev.data as Float32Array;\r\n\r\n                        if (outputStream && !outputStream.isClosed) {\r\n                            const waveFrame = waveStreamEncoder.encode(inputFrame);\r\n                            if (!!waveFrame) {\r\n                                outputStream.writeStreamChunk({\r\n                                    buffer: waveFrame,\r\n                                    isEnd: false,\r\n                                    timeReceived: Date.now(),\r\n                                });\r\n                                needHeader = false;\r\n                            }\r\n                        }\r\n                    };\r\n                    micInput.connect(workletNode);\r\n                    workletNode.connect(context.destination);\r\n                    this.privMediaResources = {\r\n                        scriptProcessorNode: workletNode,\r\n                        source: micInput,\r\n                        stream: mediaStream,\r\n                    };\r\n                })\r\n                .catch(() => {\r\n                    const scriptNode = (() => {\r\n                        let bufferSize = 0;\r\n                        try {\r\n                            return context.createScriptProcessor(bufferSize, 1, 1);\r\n                        } catch (error) {\r\n                            // Webkit (<= version 31) requires a valid bufferSize.\r\n                            bufferSize = 2048;\r\n                            let audioSampleRate = context.sampleRate;\r\n                            while (bufferSize < 16384 && audioSampleRate >= (2 * desiredSampleRate)) {\r\n                                bufferSize <<= 1;\r\n                                audioSampleRate >>= 1;\r\n                            }\r\n                            return context.createScriptProcessor(bufferSize, 1, 1);\r\n                        }\r\n                    })();\r\n                    scriptNode.onaudioprocess = (event: AudioProcessingEvent) => {\r\n                        const inputFrame = event.inputBuffer.getChannelData(0);\r\n\r\n                        if (outputStream && !outputStream.isClosed) {\r\n                            const waveFrame = waveStreamEncoder.encode(inputFrame);\r\n                            if (!!waveFrame) {\r\n                                outputStream.writeStreamChunk({\r\n                                    buffer: waveFrame,\r\n                                    isEnd: false,\r\n                                    timeReceived: Date.now(),\r\n                                });\r\n                                needHeader = false;\r\n                            }\r\n                        }\r\n                    };\r\n                    micInput.connect(scriptNode);\r\n                    scriptNode.connect(context.destination);\r\n                    this.privMediaResources = {\r\n                        scriptProcessorNode: scriptNode,\r\n                        source: micInput,\r\n                        stream: mediaStream,\r\n                    };\r\n                });\r\n        } else {\r\n            throw new Error(\"Unable to start audio worklet node for PCMRecorder\");\r\n        }\r\n    }\r\n\r\n    public releaseMediaResources = (context: AudioContext): void => {\r\n        if (this.privMediaResources) {\r\n            if (this.privMediaResources.scriptProcessorNode) {\r\n                this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\r\n                this.privMediaResources.scriptProcessorNode = null;\r\n            }\r\n            if (this.privMediaResources.source) {\r\n                this.privMediaResources.source.disconnect();\r\n                if (this.privStopInputOnRelease) {\r\n                    this.privMediaResources.stream.getTracks().forEach((track: any) => track.stop());\r\n                }\r\n                this.privMediaResources.source = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public setWorkletUrl(url: string): void {\r\n        this.privSpeechProcessorScript = url;\r\n    }\r\n}\r\n\r\ninterface IMediaResources {\r\n    source: MediaStreamAudioSourceNode;\r\n    scriptProcessorNode: ScriptProcessorNode | AudioWorkletNode;\r\n    stream: MediaStream;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}