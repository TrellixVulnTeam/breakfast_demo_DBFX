{"ast":null,"code":"\"use strict\"; // Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConversationServiceAdapter = void 0;\n\nvar Exports_1 = require(\"../../common/Exports\");\n\nvar Exports_2 = require(\"../../sdk/Exports\");\n\nvar Exports_3 = require(\"../Exports\");\n\nvar ConversationConnectionMessage_1 = require(\"./ConversationConnectionMessage\");\n\nvar ConversationRequestSession_1 = require(\"./ConversationRequestSession\");\n\nvar ConversationTranslatorEventArgs_1 = require(\"./ConversationTranslatorEventArgs\");\n\nvar ConversationTranslatorInterfaces_1 = require(\"./ConversationTranslatorInterfaces\");\n\nvar Exports_4 = require(\"./ServiceMessages/Exports\");\n/***\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\n */\n\n\nvar ConversationServiceAdapter = function (_super) {\n  __extends(ConversationServiceAdapter, _super);\n\n  function ConversationServiceAdapter(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {\n    var _this = _super.call(this, authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) || this;\n\n    _this.privLastPartialUtteranceId = \"\";\n\n    _this.noOp = function () {// operation not supported\n    };\n\n    _this.privConversationServiceConnector = conversationServiceConnector;\n    _this.privConversationAuthentication = authentication;\n    _this.receiveMessageOverride = _this.receiveConversationMessageOverride;\n    _this.recognizeOverride = _this.noOp;\n    _this.postConnectImplOverride = _this.conversationConnectImpl;\n    _this.configConnectionOverride = _this.configConnection;\n    _this.disconnectOverride = _this.privDisconnect;\n    _this.privConversationRequestSession = new ConversationRequestSession_1.ConversationRequestSession(Exports_1.createNoDashGuid());\n    _this.privConversationConnectionFactory = connectionFactory;\n    _this.privConversationIsDisposed = false;\n    return _this;\n  }\n\n  ConversationServiceAdapter.prototype.isDisposed = function () {\n    return _super.prototype.isDisposed.call(this) || this.privConversationIsDisposed;\n  };\n\n  ConversationServiceAdapter.prototype.dispose = function (reason) {\n    return __awaiter(this, void 0, void 0, function () {\n      var connection;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.privConversationIsDisposed = true;\n            if (!this.privConnectionConfigPromise) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , this.privConnectionConfigPromise];\n\n          case 1:\n            connection = _a.sent();\n            return [4\n            /*yield*/\n            , connection.dispose(reason)];\n\n          case 2:\n            _a.sent();\n\n            _a.label = 3;\n\n          case 3:\n            return [4\n            /*yield*/\n            , _super.prototype.dispose.call(this, reason)];\n\n          case 4:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  ConversationServiceAdapter.prototype.sendMessage = function (message) {\n    return __awaiter(this, void 0, void 0, function () {\n      var connection;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.fetchConnection()];\n\n          case 1:\n            connection = _a.sent();\n            return [2\n            /*return*/\n            , connection.send(new ConversationConnectionMessage_1.ConversationConnectionMessage(Exports_1.MessageType.Text, message))];\n        }\n      });\n    });\n  };\n\n  ConversationServiceAdapter.prototype.sendMessageAsync = function (message) {\n    return __awaiter(this, void 0, void 0, function () {\n      var sink, connection;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            sink = new Exports_1.Deferred();\n            return [4\n            /*yield*/\n            , this.fetchConnection()];\n\n          case 1:\n            connection = _a.sent();\n            return [4\n            /*yield*/\n            , connection.send(new ConversationConnectionMessage_1.ConversationConnectionMessage(Exports_1.MessageType.Text, message))];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  ConversationServiceAdapter.prototype.privDisconnect = function () {\n    if (this.terminateMessageLoop) {\n      return;\n    }\n\n    this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, Exports_2.CancellationReason.Error, Exports_2.CancellationErrorCode.NoError, \"Disconnecting\");\n    this.terminateMessageLoop = true;\n    return Promise.resolve();\n  };\n\n  ConversationServiceAdapter.prototype.processTypeSpecificMessages = function (connectionMessage, successCallback, errorCallBack) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , true];\n      });\n    });\n  }; // Cancels recognition.\n\n\n  ConversationServiceAdapter.prototype.cancelRecognition = function (sessionId, requestId, cancellationReason, errorCode, error) {\n    this.terminateMessageLoop = true;\n    var cancelEvent = new Exports_2.ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n\n    try {\n      if (!!this.privConversationServiceConnector.canceled) {\n        this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\n      }\n    } catch (_a) {// continue on error\n    }\n  };\n  /**\n   * Establishes a websocket connection to the end point.\n   */\n\n\n  ConversationServiceAdapter.prototype.conversationConnectImpl = function (connection) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        this.privConnectionLoop = this.startMessageLoop();\n        return [2\n        /*return*/\n        , connection];\n      });\n    });\n  };\n  /**\n   * Process incoming websocket messages\n   */\n\n\n  ConversationServiceAdapter.prototype.receiveConversationMessageOverride = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var communicationCustodian, connection, message, sessionId, sendFinal, commandPayload_1, participantsPayload, participantsResult, joinParticipantPayload, joiningParticipant, leavingParticipant, disconnectParticipant, token, speechPayload, speechResult, textPayload, textResult, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.isDisposed() || this.terminateMessageLoop) {\n              return [2\n              /*return*/\n              , Promise.resolve()];\n            }\n\n            communicationCustodian = new Exports_1.Deferred();\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.fetchConnection()];\n\n          case 2:\n            connection = _a.sent();\n            return [4\n            /*yield*/\n            , connection.read()];\n\n          case 3:\n            message = _a.sent();\n\n            if (this.isDisposed() || this.terminateMessageLoop) {\n              // We're done.\n              communicationCustodian.resolve();\n              return [2\n              /*return*/\n              , Promise.resolve()];\n            }\n\n            if (!message) {\n              return [2\n              /*return*/\n              , this.receiveConversationMessageOverride()];\n            }\n\n            sessionId = this.privConversationRequestSession.sessionId;\n            sendFinal = false;\n\n            try {\n              switch (message.conversationMessageType.toLowerCase()) {\n                case \"info\":\n                case \"participant_command\":\n                case \"command\":\n                  commandPayload_1 = Exports_4.CommandResponsePayload.fromJSON(message.textBody);\n\n                  switch (commandPayload_1.command.toLowerCase()) {\n                    /**\n                     * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\n                     * The consuming client must wait for this message to arrive\n                     * before starting to send their own data.\n                     */\n                    case \"participantlist\":\n                      participantsPayload = Exports_4.ParticipantsListPayloadResponse.fromJSON(message.textBody);\n                      participantsResult = participantsPayload.participants.map(function (p) {\n                        var participant = {\n                          avatar: p.avatar,\n                          displayName: p.nickname,\n                          id: p.participantId,\n                          isHost: p.ishost,\n                          isMuted: p.ismuted,\n                          isUsingTts: p.usetts,\n                          preferredLanguage: p.locale\n                        };\n                        return participant;\n                      });\n\n                      if (!!this.privConversationServiceConnector.participantsListReceived) {\n                        this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\n                     * This is sent at the start of the Conversation\n                     */\n\n                    case \"settranslatetolanguages\":\n                      if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload_1.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload_1.value, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\n                     * If sent by the participant the setting will effect only their own profanity level.\n                     * If sent by the host, the setting will effect all participants including the host.\n                     * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\n                     */\n\n                    case \"setprofanityfiltering\":\n                      if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload_1.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload_1.value, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'SetMute' is sent if the participant has been muted by the host.\n                     * Check the 'participantId' to determine if the current user has been muted.\n                     */\n\n                    case \"setmute\":\n                      if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload_1.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setMute, commandPayload_1.value, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'SetMuteAll' is sent if the Conversation has been muted by the host.\n                     */\n\n                    case \"setmuteall\":\n                      if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\n                        this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.MuteAllEventArgs(commandPayload_1.value, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\n                     */\n\n                    case \"roomexpirationwarning\":\n                      if (!!this.privConversationServiceConnector.conversationExpiration) {\n                        this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new Exports_2.ConversationExpirationEventArgs(commandPayload_1.value, this.privConversationRequestSession.sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\n                     */\n\n                    case \"setusetts\":\n                      if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload_1.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.setUseTTS, commandPayload_1.value, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'SetLockState' is set if the host has locked or unlocked the Conversation.\n                     */\n\n                    case \"setlockstate\":\n                      if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\n                        this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.LockRoomEventArgs(commandPayload_1.value, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'ChangeNickname' is received if a user changes their display name.\n                     * Any cached particpiants list should be updated to reflect the display name.\n                     */\n\n                    case \"changenickname\":\n                      if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                        this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantAttributeEventArgs(commandPayload_1.participantId, ConversationTranslatorInterfaces_1.ConversationTranslatorCommandTypes.changeNickname, commandPayload_1.nickname, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'JoinSession' is sent when a user joins the Conversation.\n                     */\n\n                    case \"joinsession\":\n                      joinParticipantPayload = Exports_4.ParticipantPayloadResponse.fromJSON(message.textBody);\n                      joiningParticipant = {\n                        avatar: joinParticipantPayload.avatar,\n                        displayName: joinParticipantPayload.nickname,\n                        id: joinParticipantPayload.participantId,\n                        isHost: joinParticipantPayload.ishost,\n                        isMuted: joinParticipantPayload.ismuted,\n                        isUsingTts: joinParticipantPayload.usetts,\n                        preferredLanguage: joinParticipantPayload.locale\n                      };\n\n                      if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\n                        this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantEventArgs(joiningParticipant, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'LeaveSession' is sent when a user leaves the Conversation'.\n                     */\n\n                    case \"leavesession\":\n                      leavingParticipant = {\n                        id: commandPayload_1.participantId\n                      };\n\n                      if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\n                        this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ParticipantEventArgs(leavingParticipant, sessionId));\n                      }\n\n                      break;\n\n                    /**\n                     * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\n                     * Check the 'ParticipantId' to check whether the message is for the current user.\n                     */\n\n                    case \"disconnectsession\":\n                      disconnectParticipant = {\n                        id: commandPayload_1.participantId\n                      };\n                      break;\n\n                    case \"token\":\n                      token = new Exports_3.CognitiveTokenAuthentication(function (authFetchEventId) {\n                        var authorizationToken = commandPayload_1.token;\n                        return Promise.resolve(authorizationToken);\n                      }, function (authFetchEventId) {\n                        var authorizationToken = commandPayload_1.token;\n                        return Promise.resolve(authorizationToken);\n                      });\n                      this.authentication = token;\n                      break;\n\n                    /**\n                     * Message not recognized.\n                     */\n\n                    default:\n                      break;\n                  }\n\n                  break;\n\n                /**\n                 * 'partial' (or 'hypothesis') represents a unfinalized speech message.\n                 */\n\n                case \"partial\":\n                /**\n                 * 'final' (or 'phrase') represents a finalized speech message.\n                 */\n\n                case \"final\":\n                  speechPayload = Exports_4.SpeechResponsePayload.fromJSON(message.textBody);\n                  speechResult = new Exports_2.ConversationTranslationResult(speechPayload.participantId, this.getTranslations(speechPayload.translations), speechPayload.language, undefined, undefined, speechPayload.recognition, undefined, undefined, message.textBody, undefined);\n\n                  if (speechPayload.isFinal) {\n                    // check the length, sometimes empty finals are returned\n                    if (speechResult.text !== undefined && speechResult.text.length > 0) {\n                      sendFinal = true;\n                    } else if (speechPayload.id === this.privLastPartialUtteranceId) {\n                      // send final as normal. We had a non-empty partial for this same utterance\n                      // so sending the empty final is important\n                      sendFinal = true;\n                    } else {// suppress unneeded final\n                    }\n\n                    if (sendFinal) {\n                      if (!!this.privConversationServiceConnector.translationReceived) {\n                        this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.final, speechResult, sessionId));\n                      }\n                    }\n                  } else if (speechResult.text !== undefined) {\n                    this.privLastPartialUtteranceId = speechPayload.id;\n\n                    if (!!this.privConversationServiceConnector.translationReceived) {\n                      this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\n                    }\n                  }\n\n                  break;\n\n                /**\n                 * \"translated_message\" is a text message or instant message (IM).\n                 */\n\n                case \"translated_message\":\n                  textPayload = Exports_4.TextResponsePayload.fromJSON(message.textBody);\n                  textResult = new Exports_2.ConversationTranslationResult(textPayload.participantId, this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);\n\n                  if (!!this.privConversationServiceConnector.translationReceived) {\n                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationTranslatorEventArgs_1.ConversationReceivedTranslationEventArgs(ConversationTranslatorInterfaces_1.ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\n                  }\n\n                  break;\n\n                default:\n                  // ignore any unsupported message types\n                  break;\n              }\n            } catch (e) {// continue\n            }\n\n            return [2\n            /*return*/\n            , this.receiveConversationMessageOverride()];\n\n          case 4:\n            e_1 = _a.sent();\n            this.terminateMessageLoop = true;\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [2\n            /*return*/\n            , communicationCustodian.promise];\n        }\n      });\n    });\n  };\n\n  ConversationServiceAdapter.prototype.startMessageLoop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var messageRetrievalPromise, r, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.isDisposed()) {\n              return [2\n              /*return*/\n              , Promise.resolve()];\n            }\n\n            this.terminateMessageLoop = false;\n            messageRetrievalPromise = this.receiveConversationMessageOverride();\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , messageRetrievalPromise];\n\n          case 2:\n            r = _a.sent();\n            return [2\n            /*return*/\n            , r];\n\n          case 3:\n            error_1 = _a.sent();\n            this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", Exports_2.CancellationReason.Error, Exports_2.CancellationErrorCode.RuntimeError, error_1);\n            return [2\n            /*return*/\n            , null];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // Takes an established websocket connection to the endpoint\n\n\n  ConversationServiceAdapter.prototype.configConnection = function () {\n    var _this = this;\n\n    if (this.isDisposed()) {\n      return Promise.resolve(undefined);\n    }\n\n    if (this.privConnectionConfigPromise) {\n      return this.privConnectionConfigPromise.then(function (connection) {\n        if (connection.state() === Exports_1.ConnectionState.Disconnected) {\n          _this.privConnectionId = null;\n          _this.privConnectionConfigPromise = null;\n          return _this.configConnection();\n        }\n\n        return _this.privConnectionConfigPromise;\n      }, function (error) {\n        _this.privConnectionId = null;\n        _this.privConnectionConfigPromise = null;\n        return _this.configConnection();\n      });\n    }\n\n    if (this.terminateMessageLoop) {\n      return Promise.resolve(undefined);\n    }\n\n    this.privConnectionConfigPromise = this.connectImpl().then(function (connection) {\n      return connection;\n    });\n    return this.privConnectionConfigPromise;\n  };\n\n  ConversationServiceAdapter.prototype.getTranslations = function (serviceResultTranslations) {\n    var translations;\n\n    if (undefined !== serviceResultTranslations) {\n      translations = new Exports_2.Translations();\n\n      for (var _i = 0, serviceResultTranslations_1 = serviceResultTranslations; _i < serviceResultTranslations_1.length; _i++) {\n        var translation = serviceResultTranslations_1[_i];\n        translations.set(translation.lang, translation.translation);\n      }\n    }\n\n    return translations;\n  };\n\n  return ConversationServiceAdapter;\n}(Exports_3.ServiceRecognizerBase);\n\nexports.ConversationServiceAdapter = ConversationServiceAdapter;","map":{"version":3,"sources":["src/common.speech/Transcription/ConversationServiceAdapter.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionMessage,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IAudioSource,\r\n    IConnection,\r\n    MessageType,\r\n} from \"../../common/Exports\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ConversationExpirationEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationResult,\r\n    Translations\r\n} from \"../../sdk/Exports\";\r\nimport {\r\n    CognitiveTokenAuthentication,\r\n    IAuthentication,\r\n    IConnectionFactory,\r\n    RecognizerConfig,\r\n    ServiceRecognizerBase\r\n} from \"../Exports\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\r\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\r\nimport {\r\n    ConversationReceivedTranslationEventArgs,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs\r\n} from \"./ConversationTranslatorEventArgs\";\r\nimport {\r\n    ConversationTranslatorCommandTypes,\r\n    ConversationTranslatorMessageTypes,\r\n    IInternalParticipant\r\n} from \"./ConversationTranslatorInterfaces\";\r\nimport { ConversationTranslatorRecognizer } from \"./ConversationTranslatorRecognizer\";\r\nimport {\r\n    CommandResponsePayload,\r\n    IParticipantPayloadResponse,\r\n    IParticipantsListPayloadResponse,\r\n    ITranslationResponsePayload,\r\n    ParticipantPayloadResponse,\r\n    ParticipantsListPayloadResponse,\r\n    SpeechResponsePayload,\r\n    TextResponsePayload\r\n} from \"./ServiceMessages/Exports\";\r\n\r\n/***\r\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\r\n */\r\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\r\n    private privConversationServiceConnector: ConversationTranslatorRecognizer;\r\n    private privConversationConnectionFactory: IConnectionFactory;\r\n    private privConversationAuthFetchEventId: string;\r\n    private privConversationAuthentication: IAuthentication;\r\n    private privConversationRequestSession: ConversationRequestSession;\r\n    private privConnectionConfigPromise: Promise<IConnection>;\r\n    private privConnectionLoop: Promise<void>;\r\n    private terminateMessageLoop: boolean;\r\n    private privLastPartialUtteranceId: string = \"\";\r\n    private privConversationIsDisposed: boolean;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        conversationServiceConnector: ConversationTranslatorRecognizer) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\r\n\r\n        this.privConversationServiceConnector = conversationServiceConnector;\r\n        this.privConversationAuthentication = authentication;\r\n        this.receiveMessageOverride = this.receiveConversationMessageOverride;\r\n        this.recognizeOverride = this.noOp;\r\n        this.postConnectImplOverride = this.conversationConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\r\n        this.privConversationConnectionFactory = connectionFactory;\r\n        this.privConversationIsDisposed = false;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return super.isDisposed() || this.privConversationIsDisposed;\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        this.privConversationIsDisposed = true;\r\n        if (this.privConnectionConfigPromise) {\r\n            const connection: IConnection = await this.privConnectionConfigPromise;\r\n            await connection.dispose(reason);\r\n        }\r\n        await super.dispose(reason);\r\n    }\r\n\r\n    public async sendMessage(message: string): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        return connection.send(new ConversationConnectionMessage(\r\n            MessageType.Text,\r\n            message));\r\n    }\r\n\r\n    public async sendMessageAsync(message: string): Promise<void> {\r\n        const sink: Deferred<void> = new Deferred<void>();\r\n\r\n        const connection: IConnection = await this.fetchConnection();\r\n\r\n        await connection.send(new ConversationConnectionMessage(MessageType.Text, message));\r\n    }\r\n\r\n    protected privDisconnect(): Promise<void> {\r\n        if (this.terminateMessageLoop) {\r\n            return;\r\n        }\r\n        this.cancelRecognition(this.privConversationRequestSession.sessionId,\r\n            this.privConversationRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        return Promise.resolve();\r\n    }\r\n\r\n    protected async processTypeSpecificMessages(\r\n        connectionMessage: ConnectionMessage,\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void): Promise<boolean> {\r\n        return true;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n            cancellationReason,\r\n            error,\r\n            errorCode,\r\n            undefined,\r\n            sessionId);\r\n\r\n        try {\r\n            if (!!this.privConversationServiceConnector.canceled) {\r\n                this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\r\n            }\r\n        } catch {\r\n            // continue on error\r\n        }\r\n    }\r\n\r\n    protected noOp = (): any => {\r\n        // operation not supported\r\n    }\r\n\r\n    /**\r\n     * Establishes a websocket connection to the end point.\r\n     */\r\n    protected async conversationConnectImpl(connection: Promise<IConnection>): Promise<IConnection> {\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return connection;\r\n    }\r\n\r\n    /**\r\n     * Process incoming websocket messages\r\n     */\r\n    private async receiveConversationMessageOverride(): Promise<void> {\r\n        if (this.isDisposed() || this.terminateMessageLoop) {\r\n            return Promise.resolve();\r\n        }\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<void> = new Deferred<void>();\r\n\r\n        try {\r\n            const connection: IConnection = await this.fetchConnection();\r\n            const message: ConversationConnectionMessage = await connection.read() as ConversationConnectionMessage;\r\n            if (this.isDisposed() || this.terminateMessageLoop) {\r\n                // We're done.\r\n                communicationCustodian.resolve();\r\n                return Promise.resolve();\r\n            }\r\n\r\n            if (!message) {\r\n                return this.receiveConversationMessageOverride();\r\n            }\r\n\r\n            const sessionId: string = this.privConversationRequestSession.sessionId;\r\n            let sendFinal: boolean = false;\r\n\r\n            try {\r\n                switch (message.conversationMessageType.toLowerCase()) {\r\n                    case \"info\":\r\n                    case \"participant_command\":\r\n                    case \"command\":\r\n                        const commandPayload: CommandResponsePayload = CommandResponsePayload.fromJSON(message.textBody);\r\n                        switch (commandPayload.command.toLowerCase()) {\r\n\r\n                            /**\r\n                             * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\r\n                             * The consuming client must wait for this message to arrive\r\n                             * before starting to send their own data.\r\n                             */\r\n                            case \"participantlist\":\r\n\r\n                                const participantsPayload: IParticipantsListPayloadResponse = ParticipantsListPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                const participantsResult: IInternalParticipant[] = participantsPayload.participants.map((p: IParticipantPayloadResponse) => {\r\n                                    const participant: IInternalParticipant = {\r\n                                        avatar: p.avatar,\r\n                                        displayName: p.nickname,\r\n                                        id: p.participantId,\r\n                                        isHost: p.ishost,\r\n                                        isMuted: p.ismuted,\r\n                                        isUsingTts: p.usetts,\r\n                                        preferredLanguage: p.locale\r\n                                    };\r\n                                    return participant;\r\n                                });\r\n\r\n                                if (!!this.privConversationServiceConnector.participantsListReceived) {\r\n                                    this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token,\r\n                                            participantsPayload.translateTo, participantsPayload.profanityFilter,\r\n                                            participantsPayload.roomProfanityFilter, participantsPayload.roomLocked,\r\n                                            participantsPayload.muteAll, participantsResult, sessionId));\r\n                                }\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\r\n                             * This is sent at the start of the Conversation\r\n                             */\r\n                            case \"settranslatetolanguages\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setTranslateToLanguages,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\r\n                             * If sent by the participant the setting will effect only their own profanity level.\r\n                             * If sent by the host, the setting will effect all participants including the host.\r\n                             * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\r\n                             */\r\n                            case \"setprofanityfiltering\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setProfanityFiltering,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetMute' is sent if the participant has been muted by the host.\r\n                             * Check the 'participantId' to determine if the current user has been muted.\r\n                             */\r\n                            case \"setmute\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setMute,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetMuteAll' is sent if the Conversation has been muted by the host.\r\n                             */\r\n                            case \"setmuteall\":\r\n\r\n                                if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\r\n                                    this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector,\r\n                                        new MuteAllEventArgs(commandPayload.value as boolean, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\r\n                             */\r\n                            case \"roomexpirationwarning\":\r\n\r\n                                if (!!this.privConversationServiceConnector.conversationExpiration) {\r\n                                    this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector,\r\n                                        new ConversationExpirationEventArgs(commandPayload.value as number, this.privConversationRequestSession.sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\r\n                             */\r\n                            case \"setusetts\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setUseTTS,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetLockState' is set if the host has locked or unlocked the Conversation.\r\n                             */\r\n                            case \"setlockstate\":\r\n\r\n                                if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\r\n                                    this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector,\r\n                                        new LockRoomEventArgs(commandPayload.value as boolean, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'ChangeNickname' is received if a user changes their display name.\r\n                             * Any cached particpiants list should be updated to reflect the display name.\r\n                             */\r\n                            case \"changenickname\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.changeNickname,\r\n                                            commandPayload.nickname, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'JoinSession' is sent when a user joins the Conversation.\r\n                             */\r\n                            case \"joinsession\":\r\n\r\n                                const joinParticipantPayload: ParticipantPayloadResponse = ParticipantPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                const joiningParticipant: IInternalParticipant = {\r\n                                    avatar: joinParticipantPayload.avatar,\r\n                                    displayName: joinParticipantPayload.nickname,\r\n                                    id: joinParticipantPayload.participantId,\r\n                                    isHost: joinParticipantPayload.ishost,\r\n                                    isMuted: joinParticipantPayload.ismuted,\r\n                                    isUsingTts: joinParticipantPayload.usetts,\r\n                                    preferredLanguage: joinParticipantPayload.locale,\r\n                                };\r\n\r\n                                if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantEventArgs(\r\n                                            joiningParticipant,\r\n                                            sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'LeaveSession' is sent when a user leaves the Conversation'.\r\n                             */\r\n                            case \"leavesession\":\r\n\r\n                                const leavingParticipant: IInternalParticipant = {\r\n                                    id: commandPayload.participantId\r\n                                };\r\n\r\n                                if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantEventArgs(leavingParticipant, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\r\n                             * Check the 'ParticipantId' to check whether the message is for the current user.\r\n                             */\r\n                            case \"disconnectsession\":\r\n\r\n                                const disconnectParticipant: IInternalParticipant = {\r\n                                    id: commandPayload.participantId\r\n                                };\r\n\r\n                                break;\r\n\r\n                            case \"token\":\r\n                                const token = new CognitiveTokenAuthentication(\r\n                                    (authFetchEventId: string): Promise<string> => {\r\n                                        const authorizationToken = commandPayload.token;\r\n                                        return Promise.resolve(authorizationToken);\r\n                                    },\r\n                                    (authFetchEventId: string): Promise<string> => {\r\n                                        const authorizationToken = commandPayload.token;\r\n                                        return Promise.resolve(authorizationToken);\r\n                                    });\r\n                                this.authentication = token;\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * Message not recognized.\r\n                             */\r\n                            default:\r\n                                break;\r\n                        }\r\n                        break;\r\n\r\n                    /**\r\n                     * 'partial' (or 'hypothesis') represents a unfinalized speech message.\r\n                     */\r\n                    case \"partial\":\r\n\r\n                    /**\r\n                     * 'final' (or 'phrase') represents a finalized speech message.\r\n                     */\r\n                    case \"final\":\r\n\r\n                        const speechPayload: SpeechResponsePayload = SpeechResponsePayload.fromJSON(message.textBody);\r\n\r\n                        const speechResult: ConversationTranslationResult = new ConversationTranslationResult(speechPayload.participantId,\r\n                            this.getTranslations(speechPayload.translations),\r\n                            speechPayload.language,\r\n                            undefined,\r\n                            undefined,\r\n                            speechPayload.recognition,\r\n                            undefined,\r\n                            undefined,\r\n                            message.textBody,\r\n                            undefined);\r\n\r\n                        if (speechPayload.isFinal) {\r\n                            // check the length, sometimes empty finals are returned\r\n                            if (speechResult.text !== undefined && speechResult.text.length > 0) {\r\n                                sendFinal = true;\r\n                            } else if (speechPayload.id === this.privLastPartialUtteranceId) {\r\n                                // send final as normal. We had a non-empty partial for this same utterance\r\n                                // so sending the empty final is important\r\n                                sendFinal = true;\r\n                            } else {\r\n                                // suppress unneeded final\r\n                            }\r\n\r\n                            if (sendFinal) {\r\n                                if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                        new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\r\n                                }\r\n                            }\r\n                        } else if (speechResult.text !== undefined) {\r\n                            this.privLastPartialUtteranceId = speechPayload.id;\r\n                            if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                    new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\r\n                            }\r\n                        }\r\n\r\n                        break;\r\n\r\n                    /**\r\n                     * \"translated_message\" is a text message or instant message (IM).\r\n                     */\r\n                    case \"translated_message\":\r\n\r\n                        const textPayload: TextResponsePayload = TextResponsePayload.fromJSON(message.textBody);\r\n\r\n                        const textResult: ConversationTranslationResult = new ConversationTranslationResult(textPayload.participantId,\r\n                            this.getTranslations(textPayload.translations),\r\n                            textPayload.language,\r\n                            undefined,\r\n                            undefined,\r\n                            textPayload.originalText,\r\n                            undefined,\r\n                            undefined,\r\n                            undefined,\r\n                            message.textBody,\r\n                            undefined);\r\n\r\n                        if (!!this.privConversationServiceConnector.translationReceived) {\r\n                            this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        // ignore any unsupported message types\r\n                        break;\r\n                }\r\n            } catch (e) {\r\n                // continue\r\n            }\r\n            return this.receiveConversationMessageOverride();\r\n        } catch (e) {\r\n            this.terminateMessageLoop = true;\r\n        }\r\n\r\n        return communicationCustodian.promise;\r\n    }\r\n\r\n    private async startMessageLoop(): Promise<void> {\r\n        if (this.isDisposed()) {\r\n            return Promise.resolve();\r\n        }\r\n        this.terminateMessageLoop = false;\r\n\r\n        const messageRetrievalPromise = this.receiveConversationMessageOverride();\r\n\r\n        try {\r\n            const r = await messageRetrievalPromise;\r\n            return r;\r\n        } catch (error) {\r\n            this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint\r\n    private configConnection(): Promise<IConnection> {\r\n        if (this.isDisposed()) {\r\n            return Promise.resolve<IConnection>(undefined);\r\n        }\r\n        if (this.privConnectionConfigPromise) {\r\n            return this.privConnectionConfigPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionConfigPromise = null;\r\n                    return this.configConnection();\r\n                }\r\n                return this.privConnectionConfigPromise;\r\n            }, (error: string): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionConfigPromise = null;\r\n                return this.configConnection();\r\n            });\r\n        }\r\n        if (this.terminateMessageLoop) {\r\n            return Promise.resolve<IConnection>(undefined);\r\n        }\r\n\r\n        this.privConnectionConfigPromise = this.connectImpl().then((connection: IConnection): any => {\r\n            return connection;\r\n        });\r\n\r\n        return this.privConnectionConfigPromise;\r\n    }\r\n\r\n    private getTranslations(serviceResultTranslations: ITranslationResponsePayload[]): Translations {\r\n        let translations: Translations;\r\n\r\n        if (undefined !== serviceResultTranslations) {\r\n            translations = new Translations();\r\n            for (const translation of serviceResultTranslations) {\r\n                translations.set(translation.lang, translation.translation);\r\n            }\r\n        }\r\n\r\n        return translations;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}